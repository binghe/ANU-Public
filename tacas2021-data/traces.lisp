;;;;
;;;; Random traces generation in nuXmv's XML format
;;;;

(in-package :cl-user)

;; There're 6 system variables (p, q, r, s, t, z)
;; p : 0, q/i : 1, r/x : 2, s : 3, t : 4, z : 5

(defun get-next-state ()
  (vector (random 2)    ; p
	  (random 1000) ; i (was: q), range: [-500, 500]
	  (random 1000) ; x (was: r), range: [-0.500, 0.500]
	  (random 2)    ; s
	  (random 2)    ; t
	  (random 2)    ; z
	  ))

(defparameter *number-of-traces*     100)
(defparameter *default-trace-length* 50)

(defun make-trace (&optional (length *default-trace-length*))
  (loop for i from 0 below length
	collect (get-next-state)))

(defvar *traces*) ; all states

(defun make-traces ()
  (setq *traces*
	(loop for i from 0 below *number-of-traces*
	      collect (make-trace))))

(defun write-traces-lisp (filename varname traces)
  (let ((file (merge-pathnames filename #.*compile-file-pathname*)))
    (with-open-file (s file :direction :output :if-exists :supersede)
      (format s ";;;; generated by (write-traces-1)~%~%")
      (format s "(in-package :cl-user)~%~%")
      (format s "(defparameter ~A '(~%" varname)
      (loop for i from 0 below *number-of-traces*
	    for trace in traces do
	(format s "  ~A ; trace ~A ~%" trace i))
      (format s " ))~%"))
    file))

(defun print-variable (stream state name index)
  (ecase (elt state index)
    (1 (format stream "    <value variable=\"~A\">TRUE</value>~%" name))
    (0 (format stream "    <value variable=\"~A\">FALSE</value>~%" name))))

(defun print-integer-variable (stream state name index)
  (let ((value (elt state index)))
    (format stream
	    "    <value variable=\"~A\">~D</value>~%"
	    name
	    (- value 500))))

(defun print-real-variable (stream state name index)
  (let ((value (elt state index)))
    (format stream
	    "    <value variable=\"~A\">~D</value>~%"
	    name
	    (float (/ (- value 500) 1000)))))

(defun write-trace-xml (trace &optional (id 0) (stream t))
  (format stream "<?xml version=\"1.0\" encoding=\"UTF-8\"?>~%")
  (format stream "<counter-example type=\"0\" id=\"~D\" desc=\"LTL Counterexample\">~%" id)
  (loop for i from 1
	for state in trace do
    (format stream "  <node><state id=\"~D\">~%" i)
    (print-variable         stream state "p" 0)
    (print-integer-variable stream state "i" 1)
    (print-real-variable    stream state "x" 2)
    (print-variable         stream state "s" 3)
    (print-variable         stream state "t" 4)
    (print-variable         stream state "z" 5)
    (format stream "  </state></node>~%"))
  (format stream "</counter-example>~%"))

(defun write-traces-xml (filename traces)
  (format t "writing traces in XML format: ")
  (ensure-directories-exist (merge-pathnames "traces/" #.*compile-file-pathname*))
  (loop for id from 1
	for trace in traces
	do
    (format t "~D " id)
    (let ((file (merge-pathnames (format nil "traces/~A-~D.xml" filename id)
				 #.*compile-file-pathname*)))
      (with-open-file (s file :direction :output :if-exists :supersede)
	(write-trace-xml trace id s))))
  (format t "~%"))

;; This generates (fully observable) traces in "traces/" directory
(defun run ()
  (make-traces)
  (write-traces-xml "trace" *traces*))

